#!/usr/bin/env python3
#-*- coding: utf-8 -*-
"""
 Usage:
        do_config_files.py   /path/to/myLoudspeakerFolder  [ -w ] [ |less ]

        -w   Overwrites the existing 'speaker.yml' and 'brutefir_config',
             otherwise '____.candidate' files will be provided.

 This generates the low level files needed for pre.di.c to work, i.e.:

   'brutefir_config', 'speaker.yml'

 The following files are needed under the folder 'myLoudspeaker':

   - 'myLoudspeaker.yml':

     The complete full range, multiway, subwoofer loudspeaker
     definitions including pcm names, gain, delay and polarity,
     as well as the target values for SLP and room EQ.
     
     NOTICE: It is not needed to declare any defeating DRC neither 
             PEQ sets since it will be autogenerated.
             
     ANYWAY: Please adjust the apropiate set into config/state.yml
             in order to load it when launching 'startaudio.py'

   - 'brutefir_settings.yml':
     General runtime options for Brutefir.

   -  and some '*.pcm' FIR files to be used for XO and DRC.

      (i) CONVENTIONS FOR NAMING *.pcm FIR FILES:

        XO:
          xo.someDescription.pcm

        DRC:
          drc.X_someDescription.pcm     Where X is the channel 'L' or 'R'
"""
# v1.0
#   Generates 'brutefir_config'
# v1.1
#   Also generates 'speaker.yml'
# v1.2
#   Includes PEQ
# v1.3
#   By default includes defeated sets for DRC and PEQ, so it is not needed
#   to declare any defeating sets into myLoudspeaker.yml source file.

import sys, os
import yaml
HOME = os.path.expanduser("~")
sys.path.append(HOME + "/bin")
sys.path.append(HOME + "/pre.di.c/bin")

import basepaths

# Inside 'myLoudspeaker.yml' the channels are implicit as per the column used into
# the 'fir:' field. For readability reasons it is not needed to use square brackets
# as per the yaml syntax standard.
# So, it is needed to 'patch' the yaml to convert to a convenient iterable list:
def patch_lspk(lspk):

    lspk['target_spl'] = float( lspk['target_spl'] )
    lspk['room_gain']  = float( lspk['room_gain'] )
    lspk['house_gain'] = float( lspk['house_gain'] )

    for set in lspk['drc_sets']:
        oldValue = lspk['drc_sets'][set]
        if type( oldValue ) != list:
            newValue = [ x.strip() for x in str(oldValue).split() ]
            lspk['drc_sets'][set] = newValue

    for set in lspk['xo_sets']:
        for way in lspk['xo_sets'][set]:
            for param in lspk['xo_sets'][set][way]:
                oldValue = lspk['xo_sets'][set][way][param]
                if type( oldValue ) != list:
                    newValue = [ x.strip() for x in str(oldValue).split() ]
                    lspk['xo_sets'][set][way][param] = newValue

    return lspk

def scan_xo(baseDir):
    """ .pcm for XO must be named 'xo.xxxxxx.pcm' """
    XOs = []
    for root, dirs, files in os.walk(baseDir, topdown=False):
        for name in [ x for x in files if     x[-4:] == '.pcm'
                                          and x[:3]  == 'xo.' ]:
            XOs.append( HOME + '/' + os.path.join(root, name) )
    return sorted(XOs)

def scan_drc(baseDir):
    """ .pcm for DRC must be named 'drc.xxxxxx.pcm' """
    DRCs = []
    for root, dirs, files in os.walk(baseDir, topdown=False):
        for name in [ x for x in files if     x[-4:] == '.pcm'
                                          and x[:4]  == 'drc.' ]:
            DRCs.append( HOME + '/' + os.path.join(root, name) )
    return sorted(DRCs)

def do_header():
    h1 =  '# --------------------------------------------\n'
    h1 += '# generated by do_brutefir_config.py as per:  \n'
    h1 += '#     ' + lspk_fname + '\n'
    h1 += '#     ' + bfSettings_fname + '\n'
    h1 += '# --------------------------------------------\n'

    h2 = ('''
    # modulo "cli" para puerto tct/ip para consultas y cambios al vuelo
    # y modulo "eq" para el EQ del preamplificador de predic

    logic:

    "cli" { port: 3000; },

    "eq"  {
        #debug_dump_filter: "~/brutefir-rendered-%d";
        {
         coeff: "c.eq";
         bands: 18.0, 20.0, 22.4, 25.0, 28.0, 32.0, 36.0, 40.0, 44.8, 50.0, 56.0, 63.0, 71.0, 80.0, 90.0, 100.0, 112.0, 126.0, 142.0, 160.0, 180.0, 200.0, 224.0, 250.0, 280.0, 320.0, 360.0, 400.0, 448.0, 500.0, 560.0, 630.0, 710.0, 800.0, 900.0, 1000.0, 1120.0, 1260.0, 1420.0, 1600.0, 1800.0, 2000.0, 2240.0, 2500.0, 2800.0, 3200.0, 3600.0, 4000.0, 4480.0, 5000.0, 5600.0, 6300.0, 7100.0, 8000.0, 9000.0, 10000.0, 11200.0, 12600.0, 14200.0, 16000.0, 18000.0, 20000.0, 22040.0;
        };
    };
    ''').replace('    ','')

    return (h1+h2)

def do_general():

    header =    ('''
                # -----------------------------------
                # --------- GENERAL SETTINGS --------
                # -----------------------------------
                ''').replace('    ','')

    tmp = ''
    for prop in bfir_cfg:
        value = bfir_cfg[prop]
        tmp += (prop + ':').ljust(20) + str(value).lower() + ' ;\n'

    return (header + tmp)

def do_io(xo_set):
    header = ('''
    # ---------------------------------
    # -------------  I/O: -------------
    # mandatory:  input "in.L", "in.R"
    # ---------------------------------
    ''').replace('    ','')

    # INPUT
    tmp =  '\ninput "in.L", "in.R" {\n'
    tmp += '    # does not connect inputs in jack:\n'
    # will be better if reading brutefir_ports from config.yml...:
    tmp += '    device:   "jack" { ports: ""/"in.L", ""/"in.R"; };\n'
    tmp += '    sample:   "AUTO";\n'
    tmp += '    channels: 2/0,1;\n'
    tmp += '};\n'

    # OUTPUT
    fs = lspk['fs']
    outputs = outputsMap( xo_set )
    totalOuts    = str( len(outputs) )
    seqOuts      = ','.join( [str(x) for x in range( len(outputs) ) ] )

    msecList     = [ x['delay'] for x in outputs ]
    msecChain    = ', '.join( msecList )
    samplesList  = [ int(round(float(x) / 1000.0 * fs)) for x in msecList ]
    samplesChain  = ', '.join( [ str(x) for x in samplesList ] )

    outChain = [ out['outName'] for out in outputs ]
    outChain = ', '.join( [ '"'+x+'"' for x in outChain ] )

    tmp += '\noutput ' + outChain + ' {\n'
    tmp += '    # output mapping to the sound card jack ports:\n'
    tmp += do_mapChain(outputs) + '\n'
    tmp += '    sample:   "AUTO";\n'
    tmp += '    channels: ' + totalOuts + '/' + seqOuts + ';\n'
    tmp += '    maxdelay: 1000;\n'
    tmp += '    dither:   true;\n'
    tmp += '    delay:    ' + samplesChain + '; # (samples)\n'
    tmp += '    #   ~:    ' + msecChain + ' (ms)\n'
    tmp += '};\n'

    return header + tmp

def outputsMap(xo_set):
    ''' outsMap will be an orderd list wich index will correspond
        to the physical order of jack sound card ports
    '''
    outsMap = []

    for way in xo_set:

        # Below will be (0,1) for regular ways, or (0) for a single subwoofer:
        listOfChannels = tuple(range(len( xo_set[way]['delay_ms'] )))

        for cha in listOfChannels:
            delay = xo_set[way]['delay_ms'][cha]
            if way != 'sw':
                cha = ('L','R')[cha]
                outsMap.append( { 'outName': way + '.' + cha, 'delay':delay } )
            else:
                outsMap.append( { 'outName': way,             'delay':delay } )

    return (outsMap)

def do_mapChain(outputs):
    '''
    input:  A list of outputs and his properties, i.e.:
            [ {'outName': 'lo.L', 'delay': '0.4'},  etc... ]

    output: The text chain usable for brutefir's jack ports definition.
            Example:
            device: "jack" { ports:
                "system:playback_1"/"lo_L", "system:playback_2"/"lo_R",
                 "system:playback_3"/"hi_L", "system:playback_4"/"hi_R";
                 "system:playback_5"/"sw_AMR";
            };
    '''
    p = 1
    tmp =  '    device: "jack" { ports:\n        '

    for o in outputs:
        if p>2 and p%2 != 0:
            tmp += '\n        '
        tmp += '"system:playback_' + str(p) + '"/"' + o['outName'] + '", '
        p += 1

    tmp = tmp[:-2] + ';\n    };'

    return tmp

def do_coeffs():
    tmp = ''

    tmp += ('''
    # --------------------------------------------
    # --------- COEFFs for EQ & LOUDNESS ---------
    # 1 block length is enough to smooth eq curves
    # --------------------------------------------
    ''').replace('    ','')

    tmp += ('''
    coeff "c.eq" {
        filename: "dirac pulse";
        shared_mem: true;
        blocks: 1;
    };
    ''').replace('     ', ' ').replace('    #', '#').replace('    coeff', 'coeff').replace('    }', '}')
    # naive but it works

    tmp += ('''
    # -----------------------------------------
    # -------  COEFFs for DRC & XOVER: --------
    # PCMs found under the loudspeaker folder
    # -----------------------------------------
    ''').replace('    ','')

    # coeff "c.drc.1.L" {
    # 	filename:    "drc1/L_drc_pba1.pcm";
    # 	format:      "FLOAT_LE";
    # 	shared_mem:  false;
    # 	attenuation: 0;
    # };

    for pcm in ( drc_pcms + xo_pcms ):
        cname = pcm.split('/')[-1].split('.')[1]
        tmp += '\ncoeff "' + cname + '" {\n'
        tmp += '    filename:    "' + pcm + '";\n'
        tmp += '    format:      "FLOAT_LE";\n'
        tmp += '    shared_mem:  false;\n'
        tmp += '    attenuation: 0;\n'
        tmp += '};\n'

    return tmp

def do_filtering_eq():

    tmp = ('''
    # ---------------------------------------------------------
    # ---------------- CONVOLVER:  EQ filters  ----------------
    # Madatory filters "f.eq.L" "f.eq.R" for VOLUME & EQ curves
    # STARTUP attenuation: 100 dB  ;-)
    # ---------------------------------------------------------
    ''').replace('    ','')

    tmp += ('''
    filter "f.eq.L" {
        from_inputs:  "in.L"/100/1;
        to_filters:   "f.drc.L", "f.drc.R";
        coeff:        "c.eq";
    };

    filter "f.eq.R" {
        from_inputs:  "in.R"/100/1;
        to_filters:   "f.drc.R", "f.drc.L";
        coeff:        "c.eq";
    };
    ''').replace('    f', 'f').replace('    to', 'to').replace('    co', 'co').replace('    }', '}')
    # naive replacing, but it works :-)

    return tmp

def do_filtering_drc(drc_set, xo_set):

    tmp = ('''
    # --------------------------------------------------------------
    # ------------------- CONVOLVER: DRC filters -------------------
    # Madatory filters "f.drc.L" "f.drc.R" for DRC & MONO/STEREO
    # From both filters "eq.L" & "eq.R" in order to operate \'mono\'
    # --------------------------------------------------------------
    ''').replace('    ','')

    # filter "f_drc_L" {
    #     from_filters: "f_eq_L"//1, "f_eq_R"//0 ;
    #     to_filters:   "f_fr_L", "f_hi_L", "f_lo_L", "f_sw_amr", "f_sw_rel";
    #     coeff:        -1;
    # };
    # filter "f_drc_R" {
    #     from_filters: "f_eq_L"//0, "f_eq_R"//1 ;
    #     to_filters:   "f_fr_R", "f_hi_R", "f_lo_R", "f_sw_amr", "f_sw_rel";
    #     coeff:        -1;
    # };

    for in_cha in ('L','R'):
        tmp += '\nfilter "f.drc.'+in_cha+'" {\n'
        if in_cha == 'L':
            tmp += '    from_filters: "f.eq.L"//1, "f.eq.R"//0;\n'
        else:
            tmp += '    from_filters: "f.eq.L"//0, "f.eq.R"//1;\n'

        if in_cha == 'L': i = 0 # the column index
        else:             i = 1

        # Let's prepare the destination field 'to_filters'
        ways = list( xo_set.keys() )
        to_filters_regular = [ '"f.' + x + '.' + in_cha + '"' for x in ways if x[:2] != 'sw' ]
        to_filters_subwoof = [ '"f.' + x +                '"' for x in ways if x[:2] == 'sw' ]
        to_filters         = (to_filters_regular + to_filters_subwoof)
        tmp += '    to_filters:   ' + ', '.join(to_filters) + ';\n'

        # And the coeff to apply:
        pcm = drc_set[i]
        if pcm in ('none', 'nofilter', 'no', '0', '-1', ''):
            cname = '-1'
        else:
            cname = '"' + pcm.split('.')[1] + '"'
        tmp += '    coeff:        ' + cname + ';\n'

        tmp += '};\n'

    return tmp

def do_filtering_xo(xo_set):

    tmp = ('''
    # ----------------------------------------------------------
    # ------------ CONVOLVER: XOVER filters --------------------
    # Free full range, multiway, subwoofer filters to outputs
    # ----------------------------------------------------------
    ''').replace('    ','')

    # example:
    #    filter "f_fr_L" {
    #        from_filters: "f_drc_L";
    #        to_outputs:   "fr_L"/0.0/1;
    #        coeff:        "c_lp-fr_2";
    #    };
    #    ...
    #    ...
    #
    #    filter "f_sw_amr" {
    #        from_filters: "f_drc_L"/3.0, "f_drc_R"/3.0;
    #        to_outputs:   "sw_amr"/-15.0/1;
    #        coeff:        "c_lp-sw_0";
    #    };

    # A regular output (could be fullrange or multiway kind of)
    for cha in ('L', 'R'):
        if cha == 'L':  chIndex = 0;
        else:           chIndex = 1;
        for way in [ w for w in xo_set if w[:2] != 'sw']:

            fname = '.'.join( ('f', way, cha) )
            atten = str( xo_set[way]['gain'][chIndex] )
            polar = str( xo_set[way]['polarity'][chIndex] )
            pcm   = xo_set[way]['fir'][chIndex]
            tmp += '\nfilter "' + fname + '" {\n'
            tmp += '    from_filters: "f.drc.' + cha + '";\n'
            tmp += '    to_outputs:   "' + way + '.' + cha + '"/' + atten + '/' + polar + ';\n'
            if pcm in ('none', 'nofilter', 'no', '0', '-1', ''):
                cname = '-1'
            else:
                cname = '"' + pcm.split('.')[1] + '"'
            tmp += '    coeff:        ' + cname + ';\n'
            tmp += '};\n'

    # The subwoofer outputs
    for sub in [ s for s in xo_set if s[:2] == 'sw']:

        fname = '.'.join( ('f', sub) )
        atten = str( xo_set[sub]['gain'][0] )
        polar = str( xo_set[sub]['polarity'][0] )
        pcm   = xo_set[sub]['fir'][0]
        if pcm in ('none', 'nofilter', 'no', '0', '-1', ''):
            cname = '-1'
        else:
            cname = '"' + pcm.split('.')[1] + '"'
        tmp += '\nfilter "' + fname + '" {\n'
        tmp += '    from_filters: "f.drc.L"/3.0, "f.drc.R"/3.0;\n'
        tmp += '    to_outputs:   "' + sub + '"/' + atten + '/' + polar + ';\n'
        tmp += '    coeff:        ' + cname + ';\n'
        tmp += '};\n'

    return tmp

def get_lskpName_from_lspkFolder(path):
    """ returns the directory name of the given path """
    return [ x for x in filter(None, path.split('/')) ][-1]

def prepare_speaker_yaml():
    """ this is te pre.di.c speaker.yml sctructure """

    # note: for no coeff to be applied on a filter stage (i.e. 'coeff: -1;' in brutefir_config)
    #       it is needed to indicate 'none' into the speaker.yml file

    # THE SKELETON:
    data = """
            fs:                 ~
            ref_level_gain:     ~
            target_mag_curve:   ~
            target_pha_curve:   ~
            XO:
                filters: {}
                sets: {}
            DRC:
                filters:
                    - f.drc.L
                    - f.drc.R
                sets: {defeat: [none,none] }
            PEQ: {defeat: none}
    """
    speaker = yaml.load(data)


    # (!) PENDING TO REVIEW THIS SECTION - WORK IN PROGRESS -
    speaker['fs']               = lspk['fs']
    speaker['ref_level_gain']   = 0.0
    speaker['target_mag_curve'] = 'R20_ext-target_mag.dat'
    speaker['target_pha_curve'] = 'R20_ext-target_pha.dat'

    # THE XO.filters SECTION
    # We will complete it as the way fields are defined in the source <lspk> yaml configuration.
    # There, the ways are repeatedly declared under each set in order to adjust parameters,
    # so let's take the 'first' one by iterating over the sets:
    mySetName = next( iter( lspk['xo_sets'].keys() ) )
    mySet     = lspk['xo_sets'][mySetName]
    speaker['XO']['filters'] = list()               # initialize as empty list
    for wayName in mySet:
        if wayName != 'sw': # a stereo kind off
            speaker['XO']['filters'].append( 'f.' + wayName + '.L' )
            speaker['XO']['filters'].append( 'f.' + wayName + '.R' )
        else:
            speaker['XO']['filters'].append( 'f.' + wayName )

    # THE XO.sets SECTION, as defined in the source <lspk> yaml configuration.
    for setName in lspk['xo_sets']:
        mySet = lspk['xo_sets'][setName]
        speaker['XO']['sets'][setName] = list()     # initialize as empty list
        # Under speaker.XO.sets it is expected a list of brutefir coeffs
        # to be matched to the above 'filters' list.
        # So let's get it as per defined in the source <lspk> yaml configuration:
        for wayName in mySet:
            for pcm in mySet[wayName]['fir']:
                if pcm in ( 'none', 'nofilter', 'no', '0', '-1' , ''):
                    coeffName = 'none'
                else:
                    coeffName = pcm.split('.')[1]  # e.g:  xo.mp_DynA42_left.pcm
                speaker['XO']['sets'][setName].append( coeffName )

    # THE DRC.filters SECTION
    # This sectios is hardwired, done when skeleton.

    # THE DRC.sets SECTION
    for setName in lspk['drc_sets']:
        mySet = lspk['drc_sets'][setName]
        speaker['DRC']['sets'][setName] = list()     # initialize as empty list
        for pcm in mySet:
            if pcm in ( 'none', 'nofilter', 'no', '0', '-1' , ''):
                coeffName = 'none'
            else:
                coeffName = pcm.split('.')[1]  # e.g:  xo.mp_DynA42_left.pcm
            speaker['DRC']['sets'][setName].append( coeffName )

    # THE PEQ SECTION
    # This section can be ommited in loudspeakers/myspeaker/myspeaker.yml
    if 'peq_sets' in lspk:
        for setName in lspk['peq_sets']:
            mySet = lspk['peq_sets'][setName]
            speaker['PEQ'][setName] = mySet

    return speaker

if __name__ == "__main__":

    # Defaults to find files at current directory
    lspkFolder = os.getcwd()

    # READ COMMAND LINE OPTIONS
    if len(sys.argv) == 1:
        print(__doc__)
        sys.exit()
    overwrite = False
    for opc in sys.argv[1:]:
        if '-w' in opc:
            overwrite = True
        else:
            lspkFolder = opc
            if lspkFolder.endswith('/'):
                lspkFolder = lspkFolder[:-1]

    if overwrite:
        confirm = input("Are you sure to overwrite? ")
        if not confirm in ('Y','y') : overwrite = False

    # Our file paths:
    lspk_fname         = lspkFolder + '/' + get_lskpName_from_lspkFolder(lspkFolder) + '.yml'
    bfSettings_fname   = lspkFolder + '/brutefir_settings.yml'
    bfConfig_fname     = lspkFolder + '/brutefir_config'
    speaker_fname      = lspkFolder + '/speaker.yml'
    predicConfig_fname = f'{basepaths.main_folder}/config/config.yml'

    # SCAN PCMS to load as available coeffs in brutefir_config
    drc_pcms = scan_drc( lspkFolder )
    xo_pcms  = scan_xo( lspkFolder )

    # LOADING YAML CONFIG FILES
    # 1/ pre.di.c configuration
    f = open(predicConfig_fname, 'r')
    tmp = f.read()
    f.close()
    try:
        predic_cfg = yaml.load(tmp)
    except:
        print ( 'YAML error into ' + predicConfig_fname )
        sys.exit()
    # 2/ Brutefir general parameters  file
    f = open(bfSettings_fname, 'r')
    tmp = f.read()
    f.close()
    try:
        bfir_cfg = yaml.load(tmp)
    except:
        print ( 'YAML error into ' + bfSettings_fname )
        sys.exit()
    # 3/ lskp yaml definition
    f = open(lspk_fname, 'r')
    tmp = f.read()
    f.close()
    try:
        lspk = yaml.load(tmp)
    except:
        print ( 'YAML error into ' + lspk_file )
        sys.exit()
    # NOTICE: Channels are not explicit, neither declared as a list for end user's
    #         convenience, so channels are implicit as per the columns they are written into.
    #         It is needed to 'patch' the yaml to convert to a convenient iterable list.
    lspk = patch_lspk(lspk)

    # Prints out the lspk definition
    tmp = lspk_fname + ' (patched):'
    print( '#' * (1+len(tmp)) )
    print( tmp )
    print( '#' * (1+len(tmp)) )
    print( yaml.dump(lspk) )

    # PREPARING THE SPEAKER.YML file for pre.di.c to work
    speaker = prepare_speaker_yaml()

    # The Brutefir structure will be done based on the first drc_set and xo_set
    first_drc_set = list(lspk['drc_sets'].keys())[0] # Find the name of the first set
    first_drc_set = lspk['drc_sets' ][first_drc_set] # The set itself (the underlying dictionary)
    first_xo_set  = list(lspk['xo_sets' ].keys())[0] # Find the name of the first set
    first_xo_set = lspk['xo_sets' ][first_xo_set]    # The set itself (the underlying dictionary)

    # Brutefir IN ports are defined into the pre.di.c config.yml file
    bfir_in_ports = [ p.split(':')[-1] for p in predic_cfg['brutefir_ports'].split() ]

    # DOING THE BRUTEFIR_CONFIG structure:
    bfconfig  = do_header() + do_general()
    bfconfig += do_io(first_xo_set)
    bfconfig += do_coeffs()
    bfconfig += do_filtering_eq()
    bfconfig += do_filtering_drc(first_drc_set, first_xo_set)
    bfconfig += do_filtering_xo(first_xo_set)

    #  Saving results
    if not overwrite:
        speaker_fname   += '.candidate'
        bfConfig_fname  += '.candidate'

    # 'brutefir_config'
    f = open( bfConfig_fname, 'w')
    f.write( bfconfig )
    f.close()
    print( '#' * (2 + len(bfConfig_fname)) )
    print( bfConfig_fname + ':' )
    print( '#' * (2 + len(bfConfig_fname)) )
    print( bfconfig )

    # 'speaker.yml'
    f = open(speaker_fname,'w')
    yaml.dump(speaker, f)
    f.close()
    print( '#' * (2 + len(speaker_fname)) )
    print( speaker_fname + ':' )
    print( '#' * (2 + len(speaker_fname)) )
    print( yaml.dump(speaker) )

    print( '\n--- FILES SAVED:' )
    print( '    ' + bfConfig_fname )
    print( '    ' + speaker_fname )
    print()
    print("NOTICE: Still pending to review 'ref_level_gain' and 'target_xxx_curve' parameters")
    print()
    print("REMEMBER: Update your inputs.yml regarding the available XO_sets")
    print()
    print("PLEASE: Adjust the apropiate DRC set and PEQ into config/state.yml")
    print("        in order to load it when launching 'startaudio.py'")
    print()
